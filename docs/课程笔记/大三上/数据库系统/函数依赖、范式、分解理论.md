## 不合理的表模式设计

### 从插入和删除开始

**非主属性部分依赖主属性**，会导致插入、删除异常

> 比如一个EE系的学生全部毕业了，那么在删除学生信息的同时，相关老师的信息也被删除了

## 函数依赖

关系和属性在语义上的依赖关系

<!-- 在关系$R(U)$ -->

### 函数依赖的特性

1. 对$X\to Y$，但$Y\subsetneq X$，则称$X\to Y$为非平凡函数依赖

> “学号+姓名→姓名”是一个函数依赖，但是没有信息量（平凡） 

2.

3.

4. 若Y不函数依赖于X，记作$X\nrightarrow Y$
5. 

### 完全函数依赖与传递函数依赖

在$R(U)$中，若$X\to Y$并且对X的任何真子集X'都有$X'\nrightarrow Y$，那么称Y完全依赖于X，记为

$$X \to^{f} Y$$

> 左式属性缺一不可

### 关于函数依赖的公理和定理





## 候选键、主键和非主属性

### 候选键

设$K$为$R(U)$中的属性或属性组合，若$K→^{f}U$, 且对任意$K’ ⊂K$，$K’\nrightarrow^{f} U$则称$K$为$R(U)$上的
候选键 。

### 主键

关系$R(U)$中被选中用来作为每条记录独特唯一识别信息的候选键即为主键

### 非主属性

包含在任一候选键中的属性称**主属性**,其他属性称**非主属性**

## 范式

### 第一范式

若关系模式$R(U)$中关系的每个分量都是不可分的数据项，那么称$R(U)$属于第一范式，记作$R(U)\in 1NF$

例：`Star(name, address(street, city))`

> `Star`不属于第一范式，因为属性`address`包含了`street`和`city`两个属性，其分量不是原子

可以修改为`Star(name, street, city)`

**如果一个表能够称为一个关系，那么它至少是1NF**

### 第二范式

若$R(U)$，并且U中**每一非主属性完全函数依赖于候选键**，则称$R(U)$属于第二范式，记为$R(U)\in 2NF$

例：学生（学号，姓名，课号，课程名，成绩），主键为 { **学号，课号** }

学号→姓名，课号→课程名，均为非主属性对候选键的**部分依赖**

> 潜在风险：插入异常（没有选课的学生无法录入，没人选过的课无法录入）<br>
> 删除风险：选了某课程的所有学生毕业后，该课程的信息丢失

#### 如何让一个关系模式符号第二范式？

拆分为多个关系，让每个**被依赖的主属性**作为**主键单独建立一个表**

- 关系1：学生（**学号**，姓名）
- 关系2：课程（**课号**，课程名）
- 关系3：选课（**学号**，**课号**，成绩）

> 规律：若一个1NF的关系模式，所有候选键都是**单属性**的，那么一定是2NF<br>
> 若一个1NF的关系模式，**候选键包含所有属性**，则他一定是2NF



### 第三范式

若$R(U,F)\in 2NF$，并且$R$的每个**非主属性**都不传递函数，依赖于$R$的候选键，则称$R$为第三范式关系模式，记为$R(U)\in 3NF$

## 模式分解

关系模式$R(U)$的分解是指用R的一组子集$\rho$来代替

### 无损连接分解

对于关系模式R的分解$\rho$，可以通过对$\rho$成员的自然连接操作，将R中的数据恢复（不会缺失，也不会产生额外的数据）

即：$m_\rho(r) = r$

> 用分解后的成员中的共有属性作为连接条件，并且该属性必须为两个关系的**候选键**或者**超键**

#### 定理

设F是关系模式R上的一个函数依赖集合，$\rho=\{R_1,R_2\}$是R的一个分解，则：L当且仅当$R_1\cap R_2\to R_1-R_2$或者$R_1\cap R_2\to R_2-R_1$属于$F^+$时，$\rho$是关于F无损连接的

### 保持依赖分解

对于关系模式$R(U,F)$，U是属性全集，F是函数依赖集合，$\rho$是R的一个分解，如$\pi_{Ri}(F)$中的所有依赖的并集，**逻辑蕴含**F的每个依赖，则称分解$\rho$保持依赖集F