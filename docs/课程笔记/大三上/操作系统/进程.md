## 进程的概念与特征

OS处理程序/作业的发展

- 一次装入并运行一个“作业”
- 铜焊丝装入多个“程序”，并发执行
- 同时装入多个程序，并发执行，仅当等待I/O时切换程序执行
- 同时装入多个程序，并发执行，程序切换条件：执行时间长度到**或者**I/O等待

进程概念的提出（Multics, 1964）

不同角度下描述的进程

1. 一个正在执行的**程序**
2. 计算机中正在运行的程序的一个**实例**
3. 可以分配给处理器，并由处理器执行的一个**实体**
4. 由一个顺序执行的**代码段**、一个**当前状态**和一组相关**系统资源**所刻画的活动单元

**定义：一个执行中程序的实例**

进程给应用程序提供两个关键抽象

- 逻辑控制流
    - 每个程序似乎独占地使用CPU
    - 通过OS内核的上下文切换机制提供
- 私有地址空间
    - 每个程序似乎独占地使用内存系统
    - OS内核的虚拟内存机制提供

### 进程的基本特征

1. 动态性
2. 并发性
3. 独立性（进程是一个能独自运行的基本单位，是系统进行资源分配和调度的基本单位）
4. 异步性
5. 结构性（程序+数据+进程控制块PCB）

### 进程与程序的区别

1. 程序不具备进程的前四个特征
2. 进程和程序并非一一对应：通过多次执行，一个程序可对应多个线程；通过调用关系，一个进程可执行多个程序

## 进程的状态、转换和控制

### 进程的三种基本状态

1. 就绪状态：进程分配到了必要资源，等待获得CPU执行的状态
2. 运行状态：进程分配到了必要资源和CPU，在CPU上执行的状态
3. 阻塞状态：又称为等待态，程序正在等待某一事件而暂停运行，放弃CPU而处于暂停状态。即使CPU空闲，但是并未等到所需资源时，该进程也不能运行

### 进程状态的转换

- 新建：至少建立PCB，但进程相关的其他内容**可能**未调入主存
- 终止：进程已终止，但资源等待父进程或系统回收

<figure markdown>
![img](https://github.com/DINOREXNB/dinorexnb.github.io/blob/main/docs/images/os2-1.png?raw=true){width=500}
<figcaption>进程五状态变化图</figcaption>
</figure>

### 进程控制块PCB

1. 什么是PCB？
      - 描述进程与其他进程、系统资源的**关系**以及进程在各个不同时期所处**状态**的数据结构
2. 进程的组成
      - PCB：进程的动态特征，该进程与其他进程和系统资源的关系
      - 程序与数据：描述进程本身所应完成的功能
3. PCB内容
      - 进程描述信息：PID，UID
      - 进程控制与管理信息：进程当前状态，进程优先级，代码运行入口地址，程序的外存地址，进入内存时间，处理机占用时机，信号量使用
      - 资源分配清单：代码段指针，数据段指针，堆栈段指针，文件描述符，键盘，鼠标
      - 处理器相关信息：通用寄存器值，地址寄存器值，控制寄存器值，状态字

### 进程的控制

#### 进程的创建

允许一个进程创建另一个进程。创建者为父进程，被创建者为子进程。子进程可以继承父进程所拥有的资源，当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。

- 父进程可以通过调用`fork`函数创建一个新的运行状态的子进程
- fork(void)，返回0给子进程，返回子进程的PID给父进程，出错的话返回-1

> 子进程与父进程的PID不同

#### 进程的终止

- 引起进程终止的时间有
    - 正常结束
    - 异常结束
    - 外界干预
        - OS
        - 父进程终止
        - 父进程请求

可以通过`exit`函数进行程序的终止，约定正常结束返回0，错误时返回非0值。

> 另一种显式设置退出状态的方法是从主程序返回一个整数值

#### 进程的阻塞与唤醒

指正在执行的进程，因为期待的事情未发生，会使自己的运行态变为阻塞态。**阻塞是进程自身的一种主动行为**

等阻塞等待的条件被满足时，进程会**被唤醒进入就绪态**。。唤醒操作一般是由另一个和被唤醒进程相关的合作的进程实现的

- 可能引起进程阻塞的事件
    - 请求系统服务
    - 等待I/O操作
    - 等待数据到达
    - 无新工作

#### 进程的切换

进程切换是指处理机**从一个进程的运行转到另一个进程上运行**，在这个过程中，进程的**运行环境**发生了实质性的变化。进程切换的过程如下

1. 保存处理机上下文，包括程序计数器和其他寄存器
2. 更新PCB信息
3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列
4. 选择另一个进程执行，并更新其PCB
5. 更新内存管理的数据结构
6. 恢复处理机上下文

### 并发处理的真相

你以为的：计算机同时运行许多进程

1. 单/多用户的应用程序
2. 后台任务，如监测网络和I/O设备

实际上的：单处理器在并发地执行多个进程

1. 进程**交错进行**
2. 地址空间由虚拟内存系统管理
3. 未执行进程的寄存器保存在内存中

> 寄存器当前值保存到内存→调度下一个进程执行→加载保存的寄存器组，并切换地址空间-上下文切换

对于**多核处理器**

1. 单个芯片有多个CPU
2. 共享主存，有的还共享cache
3. 每个核可执行独立的进程，kernel负责处理器的内核调度

### 并发进程

- 每个进程都是个逻辑控制流
- 如果两个逻辑流在宏观时间上有重叠，则称这两个进程是**并发的**，否则是**顺序的**

> 在用户角度来看，并发进程的控制流在物理上是不相交的，但是我们仍然可以认为并发进程是并行运行的
>
> 进程内是串行、进程之间的并行

### 上下文切换

- **内核**：一块共享的内存驻留操作系统代码

- 内核并不是一个独立进程，但是作为其他存在的进程的一部分来运行

控制流的切换传递通过**上下文切换**进行

<figure markdown>
![img](https://github.com/DINOREXNB/dinorexnb.github.io/blob/main/docs/images/os2-2.png?raw=true){width=500}
<figcaption></figcaption>
</figure>

### 进程的一些其他操作

#### 回收子进程

- 原因
    - 进程终止后任然消耗着系统资源
    - 僵尸进程：终止了但是还没有被回收
- 回收(Reaping)
    - 父进程执行回收：收到子进程退出状态
    - 内核删除僵尸子进程
- 如果父进程不执行回收工作会发生什么？
    - 如果父进程没有回收子进程并终止，则僵尸进程将会由**Init进程**(PID=1)进行回收

## 异常控制流



## 进程间通信