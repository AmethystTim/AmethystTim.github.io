## 基本概念

- 指令系统（指令集，IS：Instruction Set）
- **指令集系统架构**（ISA）
    - 简称架构，也可以称为：处理器架构、指令集体系结构
    - 包含了程序员正确编写二进制机器语言程序所需的全部信息
    - 例如：如何使用硬件、指令格式、操作种类、操作数所能存放的寄存器组和结构，包括每个寄存器名称、编号、长度、用途
- 系列机
    - 基本指令系统相同，基本系统结构相同的计算机
    - 实际是为了解决**软件兼容**的问题，给定一个ISA，可以有不同的实现方式；例如：AMD/Intel CPU都是X86-64指令集，ARM ISA也有不同的实现方式
    - IBM 360是第一个将**ISA与其实现分离**的系列机

## 指令集架构

- ISA——抽象层，软件子系统与硬件子系统的桥梁和接口

![img](https://github.com/DINOREXNB/DINOREXNB.github.io/blob/main/docs/images/jz4-1.png?raw=true){width=600}

$$
ISA功能\quad\begin{cases}
数据类型\\存储模型\\软件可见的处理器状态\\指令集\\系统模型\\外部接口\\\dots
\end{cases}
\quad ISA特性\quad\begin{cases}
    成本和资源占用低\\简洁性：指令规整简洁\\架构和具体实现分离\\可扩展\\易于编程\\性能好\\\dots
\end{cases}
$$

## ISA位宽

指的是**通用寄存器的宽度**，决定了**寻址范围的大小**，数据运算能力的强弱

ISA位宽和指令编码长度**不一定相等**，在64位架构中，也存在大量的16位编码

## 存储器寻址

指的是：**处理器根据指令中给出的地址信息来寻找物理地址**

- 1980年以来几乎所有的机器的存储器都是按字节编址
- 一个存储器地址可以访问
    - 1个字节，2个字节，4个字节……
- 不同体系结构对字的定义是不同的
    - 16位字(Intel X86)，32位字(MIPS，RISC-V)
- 如何将字节地址映射到字地址（尾端问题）
- 一个字是否可以存放在任何字节边界上（对齐问题）

### 尾端问题

指的是：在一个（双）字内部的字节顺序问题

例如：地址`addr`存储的字为`0x89ABCDEF`，`addr`，`addr+1`，`addr+2`，`addr+4`四个字节分别存放的数据是什么？

||addr+3|addr+2|addr+1|addr|
|-|-|-|-|-|
|小端|89|AB|CD|EF|
|大端|EF|CD|AB|89|

### 对齐问题

- 假设对s个字节长的对象访问地址为A，如果A mod s=0 ，称为**边界对齐**
- 边界对齐的原因是存储器本身读写的要求，存储器本身读写通常就是边界对齐的，对于没有边界对齐的对象的访问，可能会导致两次访问或异常

## 寻址方式

指的是：通过指令中的操作数（不同方式）计算出地址

有效地址：由寻址方式说明的某一存储单元的实际存储器地址，有效地址

## 操作数类型、表示

面向应用、软件系统所处理的各种数据类型

类型由**操作码决定**，~~或者数据附加硬件解释的标记~~（现已弃用）

- 操作数在机器中的表示
    - 整型：原码、反码、补码、移码
    - 浮点：IEEE 754标准
    - 十进制：BCD码（二进制十进制表示）
    - ASCII character = 1 byte (64位寄存器能存8个ASCII字符)
    - ……


## 汇编语言（ASM）

- 如RISC-V
- 是一种低级编程语言
- 不同的架构实际上具有一组支持的不同操作

## 主流架构

1. Intel x86
2. ARM
3. RISC-V

- 早期趋势
	- 进行复杂的指令集计算
- 当前
	- 创建精简的指令集
- RISC-V介绍
	- 由UCB创建的第五代RISC的开源指令集规范
	- 适用于嵌入式的所有级别计算


## 指令语法

- 包含一个操作码和三个操作数(`op`,`dst`,`src1`,`src2`)
    - op：操作助记符
    - dst：目标寄存器
- 每一行仅允许执行一条指令
- 每一条指令只有一个操作
- “#”用于注释
- C语言中的一条指令可能要拆分为多条汇编语言实现

```RISC-V
# Fibonacci Sequence
main: add  t0, x0,  x0
		↑   ↑   ↑    ↑
	   op  dst src1 src2
# 将两个寄存器相加，将结果存在dst中
```

### 汇编指令操作对象

- 寄存器
    - 32个通用寄存器：x0~x31（仅涉及RV321的通用寄存器组）
    - 在RISC-V中，算术逻辑运算所操作的数据必须直接来自寄存器
    - x0是一个特殊寄存器，只用于全零
    - 每个寄存器都有别名便于区别，实际硬件没有区别
    - RV321指令集通用寄存器是32位，RV641是64位
- 内存
    - 可执行在寄存器和内存之间的读写
    - ......


### 整型加法

- C: `a=b+c;`
- RISC-V: `add s1, s2, s3`

### 整型减法

- C: `a=b-c;`
- RISC-V: `sub s1, s2, s3`

### 常数运算元

- immediate number
- 可以将常数存入寄存器中进行运算
- 有一个特殊的寄存器x0，村入了一个特定常数0，且该寄存器的值不可修改

### 相关运算

- $eg:a=(b+c)-(d+e);$

```RISC-V
# 假设a->s0,b->s1,c->s2,d>s3,e->s4
add t1, s1, s2
add t2, s3, s4
sub s0, t1, t2
```

### 数据传输

`memop reg, off(bAddr)`

> memop:操作运算符
> 
> reg：寄存器
> 
> bAddr: 基地址
> 
> off：偏移值

- 内存都是字节寻址
- 1word=4bytes
- 在c语言中我们可见的最小数据类型是char，为一个字节（8bit），所有的数据类型都是8bit的整数倍
- 在字寻址每个地址的每个部分相隔4个字节
- 指针算数在汇编中不会自动完成

#### 相关指令

- **load word(lw)**
	- 获取某个寄存器中的数据或者基地址加上内存的偏移量处的数据
- **store word(sw)**
	- 与lw相反，将某个值存储进某个寄存器或者基地址加上内存偏移量处的地址
- eg：整形数组的地址是s3，值b存在s2中
- C:

```C
array[10] = array[3]+b;
```

- Assembly:

```RISC-V
lw t0, 12(s3) # t0=A[3]
lw t0, s2     # t0=A[3]+b
sw t0, 40(s3) # A[10]=t0=A[3]+b
```

### 如何在起始状态存储值到内存中

```
# 汇编器指令类型之一，制定内存的数据存储，也可以将其视作内存的静态位置
# 在数字后面可以添加多个数字，用逗号隔开，便可以得到一个数组
.data
source:
	.word 3
	.word 1
	.word 4
# 告诉汇编器将以下所有内容解释为代码
.text
main:
	la t1, source
	lw t2, 0(t1)
	lw t3, 4(t1)
```

### 字节序

- 如何存储字符或者短整型？
- 大字节序：最高字节位在地址最低位
- 小字节序：最低字节位于内存最低位
- eg: s0=0x 0000 0180

|big endian|00|00|01|80|
|-|-|-|-|-|
|little endian|80|01|00|00|

### 符号扩展

- 指在保留数字符号（正负性）及其数值的情况下增加二进制数字位数的操作
- 若为正数，如001010，则直接在最高位前添加0
- 若为负数，如11 1111 0001（十进制的-15），则直接在最高位添加1

### 其他的存储与加载指令

#### Byte instruction

- load byte(lb)
	- 高位的三个字节通过“符号扩展”填充
- store byte(sb)
	- 仅读取一个字节（8bit），高位的三个字节均被忽略
- eg: s0=0x00000180

```
lb s1,1(s0) # s1=0x00000001
# 将八位扩展成32位，因为s0最高位是1，所以前30位（2进制）都应该是1，所以用16进制表示为“F”（此时每一位代表4bit）
lb s2,0(s0) # s2=0xFFFFFF80
# 此时只看s2的最低1字节内容（16进制最低的两位）
sb s2,2(s0) # *(s0)=0x00800180
```